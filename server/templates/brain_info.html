<!DOCTYPE html>

<html>
    <head>
        <title>MHA Brain Information</title>
        <meta charset="utf-8">
    </head>
    <body>
           
        <!-- div for axial profile -->
        <div>
            <h3>AXIAL</h3>
            <canvas id="top_view"></canvas>
            <input type="range" class="slider" id="top_view_slider">
            <label for='top_view_index'>index</label><input type="text" id='top_view_index'/>
            <input type='button' value='select' id='top_view_select'/>
        </div>

        <!-- div for sagittal profile -->
        <div>
            <h3>SAGITTAL</h3>
            <canvas id="side_view"></canvas>
            <input type="range" class="slider" id="side_view_slider">
            <label for='side_view_index'>index</label><input type="text" id='side_view_index'/>
            <input type='button' value='select' id='side_view_select'/>
        </div>

        <!-- div for coronoal profile -->
        <div>
            <h3>CORONAL</h3>
            <canvas id="front_view"></canvas>
            <input type="range" class="slider" id="front_view_slider">
            <label for='front_view_index'>index</label><input type="text" id='front_view_index'/>
            <input type='button' value='select' id='front_view_select'/>
        </div>

        <fieldset>
            <legend>Pre processing</legend>
            <div>
                <input type='button' value='Isolate Brain' id='isolate_brain'/>
                <input type='button' value='Strip Skull' />
                <input type='button' value='Reset' id='reset_filters' />
            </div>
            <div>
                <input type='button' value='Bilateral Filter' id='bilateral_filter'/>
                <input type='button' value='Histogram EQ' id='histo_filter'/>
                <input type='button' value='Median Filter' id='median_filter'/>
            </div>
            <div>
                <h4>Filters Applied</h4>
                <div id='filters_list'></div>
            </div>
            <div>
                <canvas id='pre_process_out'></canvas>
            </div>
        </fieldset>

        <fieldset>
            <legend>Segmentation</legend>
            <div>
                <input type='button' value='Apply Watershed' id='watershed_button'/>
            </div>
            <div>
                <div>
                    <h5>Marker</h5>
                    <canvas id='marker'></canvas>
                </div>
                <div>
                    <h5>Local Gradient</h5>
                    <canvas id='gradient'></canvas>
                </div>
                <div>
                    <h5>Watershed</h5>
                    <canvas id='watershed'></canvas>
                </div>
            </div>
            
        </fieldset>

        <fieldset>
            <legend>Tumor Detection</legend>
            <input type='button' value='Detect Tumor'/>
            
        </fieldset>
        
        <script>
           
            
            // TODO i'd like to separate this to brain.js
            // create a model
            var brain_model = {
                data: [],
                currentView: null,
                loadData: function(data) {
                    this.data = data

                    this.views.top.slider.max = data.length -1;
                    this.views.front.slider.max = data[0].length - 1;
                    this.views.side.slider.max = data[0][0].length - 1;

                    // default value would be the middle
                    this.views.top.slider.value = Math.floor((data.length - 1) / 2);
                    this.views.front.slider.value = Math.floor(data[0].length / 2);
                    this.views.side.slider.value = Math.floor(data[0][0].length / 2);

                    this.views.top.index.value = this.views.top.slider.value;
                    this.views.front.index.value = this.views.front.slider.value;
                    this.views.side.index.value = this.views.side.slider.value;

                    this.views.redraw();

                },
                getSlice: function(type="top", index) {
                    
                    brain = this.data
                    if(type === 'top') {
                        if(index >= brain.length) {
                            index = brain.length - 1;
                        }

                        if(index < 0) {
                            index = 0
                        }
                        
                        return this.data[index]
                    } 
                    else if(type === 'side')
                    {
                        result = [];
                        
                        // check out of bounds
                        if (index >= brain[0][0].length) {
                            index = brain[0][0].length - 1
                        }

                        if (index < 0) {
                            index = 0;
                        }

                        for(var x = 0 ; x < brain.length; x++) {
                            temp_array = []
                            for(var y= 0; y < brain[x].length; y++)
                            {
                                temp_array.push(brain[x][y][index])
                            }
                            result.push(temp_array)
                        }
                        return result;
                    } 
                    else if(type === 'front') {
                        
                        result = [];

                        for(var x = 0; x < brain.length ; x++) {
                            result.push(brain[x][index])
                        }
                        return result;
                    }
                    return []
                },
                views: {
                    redraw: function() {
                        this.top.draw()
                        this.side.draw()
                        this.front.draw()
                    },
                    top: {
                        canvas: document.getElementById('top_view'),
                        slider: document.getElementById('top_view_slider'),
                        index: document.getElementById('top_view_index'),
                        select: document.getElementById('top_view_select'),
                        draw: function() {
                            this.canvas.draw(brain_model.getSlice('top', this.slider.value), 'grayscale')
                        }
                    },

                    side: {
                        canvas: document.getElementById('side_view'),
                        slider: document.getElementById('side_view_slider'),
                        index: document.getElementById('side_view_index'),
                        select: document.getElementById('side_view_select'),
                        draw: function() {
                            this.canvas.draw(brain_model.getSlice('side', this.slider.value), 'grayscale', true, true);
                        }
                    },
                    
                    front: {
                        canvas: document.getElementById('front_view'),
                        slider: document.getElementById('front_view_slider'),
                        index: document.getElementById('front_view_index'),
                        select: document.getElementById('front_view_select'),
                        draw: function() {
                            this.canvas.draw(brain_model.getSlice('front', this.slider.value), 'grayscale', true)
                        }
                    }
                },
                init: function() {
                    var views = this.views
                    for(var view in views) {
                        if (views.hasOwnProperty(view)) {
                            if(views[view].hasOwnProperty('canvas'))
                            {
                                this.attach_properties(views[view], view)
                            }
                        }
                    }
                },
                attach_properties: function(view, view_name){

                    view.canvas.draw = draw;  
                    view.slider.addEventListener('change', function(event){
                        view.index.value = this.value;
                        view.draw()
                    })
                    view.select.addEventListener('click', function(event){

                        flipx = (view_name === 'side' || view_name ==='front')? true: false;
                        flipy = (view_name === 'side')? true : false;
                        brain_model.currentView = view_name;
                        postRequest('/setPreprocessImage', {view:view_name, index:view.slider.value})
                            .then(response => response.json())
                            .then(data => {
                                pre_process_out.draw(data,'grayscale', flipx, flipy)
                            })
                            .catch(err => console.log(err))
                    })                  
                }
                
            }
            
            // this applies to canvas
            // type could be RGB | grayscale
            // separate this function, i could reuse this for the output view
            // lol, flipx shoud be flipy and vice versa but im too lazy to change
            
            function initPreprocessingFields() {

                // init the output canvas
                pre_process_out = document.getElementById('pre_process_out');
                pre_process_out.draw = draw
                
                //add event listener to buttons
                median_filter = document.getElementById('median_filter');
                histo_filter = document.getElementById('histo_filter');
                bilateral_filter = document.getElementById('bilateral_filter');
                reset_filters = document.getElementById('reset_filters')
                isolate_brain = document.getElementById('isolate_brain');

                filters_list = document.getElementById('filters_list');

                function updatePreprocessCanvas(data,flipx,flipy) {
                    pre_process_out.draw(data,'grayscale',flipx,flipy)
                }
                
                function addToFiltersList(filter) {
                    
                    list = filters_list.innerHTML;

                    if(list !== '') {
                        list += ' => '
                    }

                    list += filter

                    filters_list.innerHTML = list
                }

                function resetFiltersList() {
                    filters_list.innerHTML = '';
                }

                function requestFilter(filter) {
                    return function(event) {
                        postRequest('/applyFilter', filter)
                            .then(response => response.json())
                            .then(data => {

                                img_array = data.img_array;
                                view = brain_model.currentView;
                                
                                flipx = (view === 'side' || view ==='front')? true: false;
                                flipy = (view === 'side')? true : false;
                                updatePreprocessCanvas(data, flipx, flipy);
                                addToFiltersList(this.value);
                            })
                            .catch(err => console.log(err));
                        console.log(filter)
                    }
                }
                median_filter.addEventListener('click', requestFilter('median'));
                histo_filter.addEventListener('click', requestFilter('equalize'));
                bilateral_filter.addEventListener('click', requestFilter('bilateral'))

                isolate_brain.addEventListener('click', function(event){
                    postRequest('/isolateBrain')
                        .then(response=>response.json())
                        .then(data => {

                            view = brain_model.currentView;
                            flipx = (view === 'side' || view ==='front')? true: false;
                            flipy = (view === 'side')? true : false;
                            updatePreprocessCanvas(data,flipx,flipy);
                        })
                        .catch(err => console.log(err));
                });

                reset_filters.addEventListener('click', function(event){

                    postRequest('/resetPreprocessImage')
                        .then(response => response.json())
                        .then(data => {

                            flipx = (view === 'side' || view ==='front')? true: false;
                            flipy = (view === 'side')? true : false
                            
                            updatePreprocessCanvas(data, flipx, flipy);
                            resetFiltersList();                            
                        })
                        .catch(err => console.log(err))
                });

            }

            function initSegmentationFields() {

                watershed_button = document.getElementById('watershed_button');
                marker = document.getElementById('marker');
                gradient = document.getElementById('gradient');
                watershed = document.getElementById('watershed');

                marker.draw = draw;
                gradient.draw = draw;
                watershed.draw = draw;

                watershed_button.addEventListener('click', function(event){
                    postRequest('/applyWatershed')
                        .then(response => response.json())
                        .then(data => {
                            // console.log(data)
                            view = brain_model.currentView;
                            flipx = (view === 'side' || view ==='front')? true: false;
                            flipy = (view === 'side')? true : false;
                            marker.draw(data['marker'], 'grayscale', flipx, flipy);
                            gradient.draw(data['gradient'], 'grayscale', flipx, flipy);
                            watershed.draw(data['watershed'], 'grayscale', flipx, flipy);
                            
                        })
                        .catch(err => console.log(err));
                })

            }

            function draw(img_array, type='RGB', flipx=false, flipy=false) {
               
                var ctx = this.getContext('2d');
                
                var startx = (flipx)? img_array.length - 1 : 0;
                var endx = (flipx)? 0 : img_array.length - 1;
                var stepx = (flipx)? -1 : 1;

                var starty = (flipy)? img_array[0].length - 1 : 0;
                var endy = (flipy)? 0 : img_array[0].length -1;
                var stepy = (flipy)? -1 : 1;

                var imageWidth = img_array[0].length
                var imageHeight = img_array.length
                // change the size of the canvase depending on image array
                // TODO, use scale, its better to have a static sized canvas 
                // computation would be target / size of image array = scalar
                // scalar can be used to scale

                this.height = imageHeight;
                this.width = imageWidth;

                if(type === 'grayscale') {
                    for (i=startx, x=0; i != endx; i+=stepx, x++){
                        for(j=starty, y=0; j != endy;j+=stepy, y++){
                            var color = img_array[i][j]
                            ctx.fillStyle = "rgb("+color+","+color+","+color+")";
                            ctx.fillRect(y, x, 1, 1);
                        }
                    }
                } 
                else if (type === 'RGB') {

                }
            }

            
            function postRequest(url, data={}) {
                return fetch(url, {
                    body: JSON.stringify(data),
                    cache: 'no-cache',
                    headers: {
                        'content-type': 'application/json'
                    },
                    method: 'POST'
                })
            }
            
            function main(){

                data = {{brain.data}};
                dim = {{brain.dim}};
                
                brain_model.init();
                brain_model.loadData(data);
                
                initPreprocessingFields();
                initSegmentationFields();
            }
           
            main();

        </script>
    </body>
 </html>